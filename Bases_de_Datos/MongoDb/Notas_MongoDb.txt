Las bases de datos NoSQL tienen 4 grandes familias: Key Value Stores, basadas en grafos, columnares y basadas en documentos.
    Key Value Stores: Guardan la información en formato de llaves y valores. Las usamos para guardar cache, información de sesión de los usuarios o cosas muy sencillas. Son muy rápidas de consultar pero no podemos usarlas en casos más complejos donde necesitamos estructuras más especiales. El mejor ejemplo de estas bases de datos es Redis.
    Graph Databases: Bases de datos basadas en Grafos. Nos permiten establecer conexiones entre nuestras entidades para realizar consultas de una forma más eficiente que en bases de datos relacionales (así como Twitter o Medium donde cada publicación tiene diferentes relaciones entre sus usuarios, likes, etc). Por ejemplo: Neo4j o JanusGraph.
    Wide-column Stores: Bases de datos columnares. Tienen una llave de fila y otra de columnas para hacer consultas muy rápidas y guardar grandes cantidades de información pero modelar los datos se puede volver un poco complicado. Las usamos en Big Data, IoT, sistemas de recomendaciones, entre otras. Por ejemplo: Cassandra o HBase.
    Document Databases: Bases de datos basadas en documentos. Nos permiten guardar documentos dentro de colecciones, tiene muy buena performance y flexibilidad que nos permite modelar casos de la vida real de forma sencilla y efectiva. Por ejemplo: MongoDB o CouchBase.
MongoDB es una base de datos gratis y de código abierto No Relacional basada en documentos que nos permite guardar una gran cantidad de documentos de forma distribuida. Mongo también es el nombre de la compañía que desarrolla el código de esta base de datos.
Una de sus principales características es que nos permite guardar nuestras estructuras o documentos en formato JSON (no exactamente JSON, pero si algo muy parecido BSON) para tener una gran flexibilidad a la hora de modelar situaciones de la vida real.
Por ser una base de datos distribuida podemos hablar no de uno sino de varios servidores, lo que conocemos como el Cluster de MongoDB. Gracias a esto obtenemos una gran escalabilidad de forma horizontal (escalabilidad en cantidad de servidores).
MongoDB es “Schema Less” lo que permite que nuestros documentos tengan estructuras diferentes sin afectar su funcionamiento, algo que no podemos hacer con las tablas de las bases de datos relacionales. Su lenguaje para realizar queries, índices y agregaciones es muy expresivo.
MongoDB tiene versión community, Enterprise y Atlas(Cloud).
MongoDB Compass es el entorno gráfico de MongoDB.
Conectores son las librerías dentro de los proyectos para comunicarse con MongoDB.
Tenemos varios proveedores que nos permiten utilizar o alquilar MongoDB como servicio y en este caso vamos a usar MongoDB Atlas por ser desarrollado por las mismas personas que desarrollan MongoDB.
MongoDB Atlas tiene las siguientes características:
Aprovisionamiento automático de clusters con MongoDB
Alta disponibilidad
Altamente escalable
Seguro
Disponible en AWS, GCP y Microsoft Azure
Fácil monitoreo y optimización
Para crear nuestro cluster de base de datos debemos ir a mongodb atlas y ahi seleccionar las distintas opciones.
Se debe crear el cluster, un usuario y agregar la ip válida a la lista blanca.
https://www.mongodb.com/cloud/atlas
Con la instalación de MongoDB community nos permite tener MongoDB, la consola de MongoDB y MongoDB compass.
Se accede a C:\Program Files\MongoDB\Server\4.4\bin\mongo.exe para correr el servidor de mongo.
Dentro del servidor se pueden ejecutar los comandos de mongo.
Para conectarse con el cluster de mongo atlas se selecciona en connect y ahi se selecciona si se quiere conectar por compass o por consola, para cualquier caso solo basta con copiar la cadena y correrla ya sea en la GUI o en la consola (con carpeta de bin de Mongo).
Si el lenguaje es Orientado a Objetos de inicio transversal a la mayoría de lenguajes
    -Crea conexión. una instancia de MongoClient, recibe la dirección donde se encuentra la BD.
    -Obtener la BD. Se crea una instancia de MongoDatabase donde se pasará el parámetro el nombre de la BD donde se realizará las operaciones.
    -Acceder a una colección. Pasará el nombre de la colección donde se guardarán los documentos y a partir de MongoCollection permitirá hacer operaciones CRUD sobre nuestra BD.
Las Bases de Datos son los contenedores físicos para nuestras colecciones. Cada base de datos tiene un archivo propio en el sistema de archivos de nuestra computadora o servidor y un Cluster puede tener múltiples bases de datos.
Las Colecciones son agrupaciones de documentos. Son equivalentes a las tablas en bases de datos relacionales pero NO nos imponen un esquema o estructura rígida para guardar información.
Los Documentos son registros dentro de las colecciones. Son la unidad básica de MongoDB y son análogos a los objetos JSON pero en realidad son BSON.
Cluster:
    -Almacena varias bases de datos.
Base de datos:
    -Contenedor físico de colecciones.
    -Cada base de datos tiene su archivo propio en el sistema de archivos.
    -Un cluster puede tener múltiples bases de datos.
Colecciones:
    -Agrupación de documentos.
    -Equivalente a una tabla en las bases de datos relacionales.
    -No impone un esquema.
Documentos:
    -Un registro dentro de una colección.
    -Es análogo a un objeto JSON (BSON).
    -La unidad básica dentro de MongoDB.
Un BSON es una transformación binaria de un JSON que nos permite tener mas tipos de datos, como fechas y valores binarios.
InsertOne(). Guardar un documento dentro de la colección en la BD. Si no existe la conexión MONGODB la crea. Ingresa en formato JSON. Al hacer un insert dentro de una colección sino especifica el underscoreId (es un campo obligatorio que la BD pide) Mongo lo crea automáticamente.
InsertMany() recibe un arreglo en formato JSON y los ingresa a MongoDB automáticamente MongoDB tiene automicidad dentro de los documentos quiere decir que en el las operaciones de escritura garantiza que al escribir un documento la operación es atómica (se escribe y si no se escribe se hace rollback ( no se guarda en la BD)).
Find({CONDICION}). Se hace una consulta con un filtro y nos permite buscar uno o varios documentos que cumplan la condición.
FindOne(). Devuelve los documentos en orden natural (guarda los doc. dentro del sistema de archivos), se pueden definir conforme los índices. FinOne({_id: objectId(‘EL ID DEL OBJETO’)}).
Operador AND la forma sencilla es ponerla dentro del filtro FinOne({_id: objectId(‘EL ID DEL OBJETO’), qty: {$slte: 75} }). Si y solo si ambas son verdaderas devuelve un documento.
**UpdateOne(Filtro, nuevo valor). **De igual manera recibe un JSON o un arreglo de doc. UpdateOne({_id: objectId(‘ID DEL OBJETO’)}, {$set: {qty:130}}). updataMany() si hay más de un doc. Que cumplan con la condición cambiará el valor de cada uno
DeleteOne() hace el paso del filtro, borrará según su orden natural que encuentre con el filtro.
DeleteOne({status: “A”})
DeleteMany(). Compara el filtro con la cantidad de doc. Que cuplen con el filtro y los borra
DeleteOne({status: “A”})
id es un indice, este puede ser autogenerado por mongodb o se puede asignar manualmente.
MongoDB es atómico dentro de los documentos, garantizandonos que si el documento no se escribe entonces se hace rollback (no se guarda el documento).
Con InsertMany si no se inserta el documento completo entonces no lo guarda.
show collections//Muestra las distintas colecciones.
db.inventory.find({ item: "canvas"}).pretty()//Encuentra todos los documentos con el atributo item en canvas.
Los filtros se usan con un json.
db.inventory.findOne({ _id: ObjectId("5f298f5a171f528d3f7d5659"), qty: {$lte: 750}})//Filtro and con json y específicando una cantidad menor a 750.
db.inventory.updateOne({ _id: ObjectId("5f298f5a171f528d3f7d5659")}, {$set: {qty: 130}})//Actualiza el registro en el primer parámetro se especifican las condiciones.

Para los usuarios de Windows las variables de entorno se definen de esta forma de esta forma:
Windows CMD:
    set FLASK_APP=platzi-api
    set FLASK_ENV=development
    set PLATZI_DB_URI=“MONGO-URI”
Windows PowerShell:
    $env:FLASK_APP = "platzi-api"
    $env:FLASK_ENV = "development"
    $env:PLATZI_DB_URI = "MONGO-URI”
CRUD en la aplicación.
#Crear carrera C.
def crear_carrera(json):
    return str(db.carreras.insert_one(json).inserted_id)

#Leer carrera R.
def consultar_carrera_por_id(carrera_id):
    return dumps(db.carreras.find_one({'_id': ObjectId(carrera_id)}))#dumps convierte de bson a json.

#Actualizar carrera U.
def actualizar_carrera(carrera):
    # Esta función solamente actualiza nombre y descripción de la carrera
    return str(db.carreras.update_one( { '_id': ObjectId(carrera['_id'])} , {'$set': { 'nombre': carrera['nombre'], 'descripcion': carrera['descripcion']} } ).modified_count)

#Borrar carrera D.
def borrar_carrera_por_id(carrera_id):
    #Borra el objeto conforme al filtro.
    return str(db.carreras.delete_one({'_id': ObjectId(carrera_id)}).deleted_count)
https://docs.mongodb.com/manual/reference/bson-types/
Tipos de datos
    -Strings: Nos sirven para guardar textos.
    -Boolean: Información cierta o falsa (true y false).
    -ObjectId: Utilizan el tiempo exacto en el que generamos la consulta para siempre generan IDs únicos. Existen en BSON pero no en JSON.
    -Date: Nos sirven para guardar fechas y hacer operaciones de rangos entre ellas.
    -Números: Doubles, Integers(32 bits), Integers(64 bits) y Decimals.
    -Documentos Embebidos: Documentos dentro de otros documentos ({}).
    -Arrays: Arreglos o listas de cualquier otro tipo de datos, incluso, de otras listas.
MongoDB permite documentos embebidos ya que usa la notación json la forma de acceder a estos es nombreDocumento.subdocumento.valor .
MongoDB también permite trabajar con arreglos.
Al trabajar con documentos cada documento no puede ser mayor a 16 Mb.
https://docs.mongodb.com/manual/reference/limits/
Los esquemas son la forma en que nosotros organizamos los documentos en las colecciones, mongodb no un impone un esquema fijo como en las bases de datos sql.
MongoDB posibilita tener documentos que no tengan parecido sin embargo al momento de realizar las queries extraer la información sera más compleja.
Hay que usar MongoDB en un punto medio que los documentos tengan el mayor parecido posible con la libertad de agregar un campo si es necesario.
Las relaciones son como los documentos o entidades se encuentran enlazados unos con otros.
Los esquemas son la forma en que organizamos nuestros documentos en nuestras colecciones. MongoDB no impone ningún esquema pero podemos seguir buenas prácticas y estructurar nuestros documentos de forma parecida (no igual) para aprovechar la flexibilidad y escalabilidad de la base de datos sin aumentar la complejidad de nuestras aplicaciones.
Las relaciones son la forma en que nuestras entidades o documentos sen encuentran enlazados unos con otros. Por ejemplo: Una carrera tiene multiples cursos y cada curso tiene multiples clase.
Cuando se tienen relaciones uno a uno la mejor forma de usar mongo es usando documentos embebidos, Ejemplo: nombre, direccion ( calle, ciudad, estado).
Para relaciones uno a muchos se usan documentos embebidos con arreglos automovil:[{nombre,marca},{nombre,marca},{nombre,marca}].
Las operaciones de update en mongoDB no son transaccionales, si se tienen 10,000 documentos puede que 5,000 queden con la actualización y los demás no.
Cuando se tiene un elemento con relacion muchos a uno se recomienda colocar un identificador, ejemplo libro con identificador de editorial, si la información va a cambiar frecuentemente o puede llegar a actualizarse es muy aconsejable.
Las documentos embebidos nos ayudan a guardar la información en un solo documento y nos ahorra el tiempo que tardamos en consultar diferentes documentos a partir de referencias. Sin embargo, las referencias siguen siendo muy importantes cuando debemos actualizar información en diferentes lugares de forma continua.
Cuando se tiene un subdocumento grande y una colección con ese subdocumento como documento se puede guardar en 2 colecciones distintas el documento pero siendo uno la versión reducida del otro con solo su id y nombre, considerando hacer las 2 actualizaciones pertinentes.
Carreras
{
    "_id": "5c7605235f627d4ee1c77e81",
    "nombre": "Carrera de AWS",
    "descripcion": "En es carrera aprenderas AWS",
    "cursos": [
        {
            "_id": "",
            "nombre": "Nombre del curso"
        },
        {
            "_id": "",
            "nombre": "Nombre del curso"
        }
    ]
}
Cursos
{
    "_id": "",
    "nombre": "",
    "descripcion": "",
    "clases": [
        {
            "_id": "",
            "orden": 1,
            "nombre": "",
            "video": ["url1"]
        },
        {
            "_id": "",
            "orden": 1,
            "nombre": "",
            "video": ["url1"]
        }
    ]
}
Modo MongoDB con Documentos Embebidos: Guardar los documentos de los cursos directamente en la colección de la carrera porque es más rápido cargar las carreras y toda su información pero cuando cambie vas al psicólogo (no importa si solo quieres un curso, siempre traes toda todita la carrera).
Modo “SQL” con Referencias: Guardar los cursos en su propia colección y llamarlos desde la colección de carreras con un id de referencias. Todo bien separado y fácil de conseguir solo lo que necesitamos de cada colección pero muy costoso cuando queremos llamar a todos los cursos de una carrera porque debemos consultar colecciones diferentes una y otra vez.
Modo LEGENDA: Guardar los cursos en su propia colección pero añadir no solo una referencia sino también el nombre del curso. Así, cuando solo consultemos carrera, vamos a tener los nombres de los cursos. Solo consultamos cada curso cuando necesitamos toda todita la información. IMPORTANTE: Ojo que debemos actualizar el nombre del curso en dos partes diferentes.
Operadores para realizar queries
Para usar operadores es común usar un filtro el cual se compone de campo, operador y valor.
db.inventory.find({status: { $in: ["A", "D"]}})//Filtro que nos devuelve los documentos con status que tenga A o D.
{ <campo1>: { <operador1: <valor1> }, ... }//Estructura de un filtro con operador.
Las proyecciones nos dan la posibilidad de indicar que valores queremos traer de un documento en una consulta y cuales no.
db.inventory.findOne({status: A}, {item: 1, status: 1})
{ <campo1>: <valor1>, ...} //Se específica si traer el campo con 1 o no traerlo con 0, por defecto nos trae el id si no se quiere traer entonces se usa 0.
Operadores de comparación
    $eq : Operador igual =.
    $gt : Operador mayor que >.
    $gte : Operador mayor o igual que >=.
    $lt : Operador menor que >.
    $lte : Operador manor o igual que >=.
    $ne : Operador distinto de.
    $in : Valores dentro de un arreglo.
    $nin : Valores que no están dentro de un arreglo.
Operadores lógicos
    $and : Une queries con un and lógico (similar al uso de una coma en un filtro).
    $not : Invierte el efecto de una query.
    $nor : Une queries con un nor lógico.
    $or : Une queries con un or lógico (si una condición se cumple nos trae el documento) db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } ).
Operadores por elemento
    $exist : Documentos que cuentan con un campo específico (Ejemplo: campo edad).
    $type : Documentos que cuentan con un campo de un tipo específico (Ejemplo: tipo datetime).
Operadores para arreglos
    $all : Arreglos que contengan todos los elementos de la query db.articles.find( { tags: { $all: [ [ "ssl", "security" ] ] } } ).
    $elemMatch : Documentos que cumplen la condición del $elemMatch en uno de sus documentos (condiciones dentro de subdocumentos) db.inventory.find( { "instock": { $elemMatch: { qty: 5, warehouse: "A" } } } )
    $size : Documentos que contienen un campo tipo arreglo de un tamaño específico.
https://docs.mongodb.com/manual/tutorial/query-documents/
https://docs.mongodb.com/manual/reference/operator/update/pull/

#Con la proyección solo se regresan los campos indicados.
def consultar_curso_por_id_proyeccion(id_curso, proyeccion=None):
    return db.cursos.find_one({'_id': ObjectId(id_curso)}, proyeccion)#Regresa el curso solo con los campos indicados.

def agregar_curso(json):
    curso = consultar_curso_por_id_proyeccion(json['id_curso'], proyeccion={'nombre': 1}) #Solo guarda en carreras el nombre y el id de la clase.
    return str(db.carreras.update_one({'_id': ObjectId(json['id_carrera'])}, {'$addToSet': {'cursos': curso } }).modified_count)#Agrega el curso en la colección de carreras.

def borrar_curso_de_carrera(json):
    return str(db.carreras.update_one({'_id': ObjectId(json['id_carrera'])}, {'$pull': {'cursos': {'_id': ObjectId( json['id_curso'] ) } } } ).modified_count) #Pull saca un elemento de la pila.

https://docs.mongodb.com/manual/reference/operator/

skip() y limit()

Si tenemos una consulta que retorna 100 documentos pero solamente necesitamos los documentos del número 20 al 30, la manera de hacerlo es usando skip() y limit().

Si tenemos 100 carreras y solamente queremos las primeras 10 podemos ejecutar db.carreras.find({}).limit(10) esta nos traerá las primeras 10 carreras.

Ahora si queremos las carreras ubicadas en los puestos 40 y 50 lo que debemos hacer es db.carreras.find({}).skip(40).limit(10)

Como vemos skip() y limit() son muy útiles para realizar paginaciones, cuando tenemos consultas que retornan muchos documentos y que en algunos casos la totalidad de los documentos no es utilizada es buena práctica limitar el número de documentos que hacemos viajar entre nuestro cluster de base de datos y el código de nuestra aplicación. Esto puede ayudar a mejorar la velocidad con que las consultas son procesadas por la aplicación.

Ejercicios de práctica usando operadores
// Arreglo de ejemplo
use test
db.inventory.insertMany(

[{ _id: 1, item: { name: "ab", code: "123" }, qty: 15, tags: [ "A", "B", "C" ] },
{ _id: 2, item: { name: "cd", code: "123" }, qty: 20, tags: [ "B" ] },
{ _id: 3, item: { name: "ij", code: "456" }, qty: 25, tags: [ "A", "B" ] },
{ _id: 4, item: { name: "xy", code: "456" }, qty: 30, tags: [ "B", "A" ] },
{ _id: 5, item: { name: "mn", code: "000" }, qty: 20, tags: [ [ "A", "B" ], "C" ] }]

)

// $or
db.inventory.find({$or: [{qty: {$gt: 25}}, {qty: {$lte: 15}}]})

// $gte
db.inventory.find({qty: {$gte: 25}})

// $size
db.inventory.find({tags: {$size: 2}})

// Insertemos estos documentos de ejemplo en la colección survey
db.survey.insertMany([
{ _id: 1, results: [ { product: "abc", score: 10 }, { product: "xyz", score: 5 } ] }
{ _id: 2, results: [ { product: "abc", score: 8 }, { product: "xyz", score: 7 } ] }
{ _id: 3, results: [ { product: "abc", score: 7 }, { product: "xyz", score: 8 } ] }
])

// $elemMatch
db.survey.find(
   { results: { $elemMatch: { product: "xyz", score: { $gte: 8 } } } }
)

db.survey.find(
   { results: { $elemMatch: { product: "xyz" } } }

db.survey.find( { results: { $elemMatch: { product: "xyz", score: { $gte: 8 } } } } , { results: { $elemMatch: { product: "xyz", score: { $gte: 8 } } } })

#Coleccion par.
db.myCollection
	.find({ sequenceNumber: { $mod: [ 2, 0 ] } }) // filtro pares
	.sort({ createdAt: 'desc'  }) // ordeno de ultimo a primero
	.limit(10) // limito a 10

https://docs.mongodb.com/manual/reference/sql-aggregation-comparison/

Las agregaciones son operaciones avanzadas que podemos realizar sobre nuestra base de datos con un poco más de flexibilidad en nuestros documentos.

Pipeline de Agregaciones: Es un grupo de multiples etapas que ejecutan agregaciones en diferentes momentos. Debemos tener muy en cuenta el performance de nuestras agregaciones porque las agregaciones corren en todo el cluster.
Instrucción 2 agregaciones a cumplir
db.orders.aggregate([
   { $match: { status: "A" } },//Selecciona todos los campos con Status A
   { $group: { _id: "$cust_id", total: { $sum: "$amount" } } } //Suma los campos al momento de agrupar.
])

Map-Reduce: Nos permite definir funciones de JavaScript para ejecutar operaciones avanzadas. La función de map nos permite definir o “mappear” los campos que queremos usar y la función reduce nos permite ejecutar operaciones y devolver resultados especiales. Por ejemplo: podemos mappear algunos campos y calcular la cantidad de elementos que cumplen ciertas condiciones.

//Función que elige con que campos quedarse this es la querie.
var mapFunction1 = function() {
    emit(this.cust_id, this.price);
};

//Función que decide como actuar, suma los valores de cada arreglo.
var reduceFunction1 = function(keyCustId, valuesPrices) {
   return Array.sum(valuesPrices);
};

//Ejecutar la función mapReduce, no devuelve el resultado de la querie, sino el estado de la función.
db.orders.mapReduce(
   mapFunction1,
   reduceFunction1,
   { out: "map_reduce_example" })

//Lee la colección.
db.map_reduce_example.find().sort( { _id: 1 } )

Agregaciones de propósito único: Funciones ya definidas que nos ayudan a calcular un resultado especial pero debemos tener cuidado porque pueden mejorar o afectar el performance de la base de datos. Por ejemplo: count(), estimatedDocumentCount y distinct.

db.collection.estimatedDocumentCount() //devuelve un conteo estimado pero mas rapido.
db.collection.count() //devuelve el conteo exacto.
db.collection.distint() //devuelve los distintos valores de la coleción sin repetirse.
