/*
 * Imperial_March_328p.c
 *
 * Created: 15/05/2018 11:25:22 a. m.
 * Author : LuisFernando
 */ 

#define F_CPU 16000000
#include <util/delay.h>
#include <avr/io.h>
#include <avr/interrupt.h>
uint16_t contador=0,j=0;
const uint16_t Notas[132]={12135,65535,12135,65535,12135,65535,15289,65535,10204,65535,12135,65535,15289,65535,10204,65535,12135,65535,8099,65535,8099,65535,8099,65535,7645,65535,10204,65535,12856,65535,15289,65535,10204,65535,12135,65535,6067,65535,12135,65535,12135,65535,6067,65535,6428,65535,6810,65535,6810,65535,6067,65535,6810,65535,65535,65535,11454,65535,8581,65535,9091,65535,9631,65535,10204,65535,11454,65535,10204,65535,65535,65535,15289,65535,12856,65535,15289,65535,12135,65535,10204,65535,12135,65535,10204,65535,8099,65535,6067,65535,12135,65535,12135,65535,6067,65535,6428,65535,6810,65535,6810,65535,6067,65535,6810,65535,65535,65535,11454,65535,8581,65535,9091,65535,9631,65535,10204,65535,11454,65535,10204,65535,65535,65535,15289,65535,12856,65535,15289,65535,12135,65535};
const uint16_t Tiempo[132]={500,63,500,63,500,63,250,63,125,63,500,63,250,63,125,63,1000,63,500,63,500,63,500,63,250,63,125,63,500,63,250,63,125,63,1000,63,500,63,250,63,125,63,500,63,250,63,125,63,125,63,125,63,250,63,250,63,250,63,500,63,250,63,125,63,125,63,125,63,250,63,250,63,250,63,500,63,250,63,125,63,500,63,250,63,125,63,1000,63,500,63,250,63,125,63,500,63,250,63,125,63,125,63,125,63,250,63,250,63,250,63,500,63,250,63,125,63,125,63,125,63,250,63,250,63,250,63,500,63,250,63,125,63};
ISR(TIMER0_OVF_vect){
	TCNT0=5;
	j++;
	if (j>Tiempo[contador])
	{
		if (Notas[contador]==65535)
		{
			TCCR1A=(1<<COM1A1)|(0<<COM1A0)|(0<<COM1B1)|(0<<COM1B0)|(0<<FOC1A)|(0<<FOC1B)|(0<<WGM11)|(0<<WGM10);//Modo CTC cambiar a bajo.
		}
		else{
			TCCR1A=(0<<COM1A1)|(1<<COM1A0)|(0<<COM1B1)|(0<<COM1B0)|(0<<FOC1A)|(0<<FOC1B)|(0<<WGM11)|(0<<WGM10);//Modo CTC alternar estados.
		}
		OCR1A=Notas[contador];
		j=0;
		contador++;
		if(contador>132){
		contador=0;}
	}
}
int main(void)
{
	DDRB=0x02;
	///Configuracion Timer0 a 1ms en Modo Normal
	TCCR0A=(0<<COM0A1)|(0<<COM0A0)|(0<<COM0B1)|(0<<COM0B0)|(0<<3)|(0<<2)|(1<<WGM01)|(1<<WGM00);//Desconectar OC0,Modo Normal.
	TCCR0B=(0<<FOC0A)|(0<<FOC0B)|(0<<6)|(0<<5)|(0<<4)|(0<<CS02)|(1<<CS01)|(1<<CS00);//Prescalador de 64.
	TIMSK0=(0<<7)|(0<<6)|(0<<5)|(0<<4)|(0<<3)|(0<<OCIE0B)|(0<<OCIE0A)|(1<<TOIE0);//Interrupción por TOIE0.
	TCNT0=5;
	//Configuracion Timer 1 en CTC
	TCCR1A=(0<<COM1A1)|(1<<COM1A0)|(0<<COM1B1)|(0<<COM1B0)|(0<<FOC1A)|(0<<FOC1B)|(0<<WGM11)|(0<<WGM10);//Conectar OC1A y Modo CTC.
	TCCR1B=(0<<ICNC1)|(0<<ICES1)|(0<<5)|(0<<WGM13)|(1<<WGM12)|(0<<CS12)|(1<<CS11)|(0<<CS10);//Modo CTC y Prescalador a 8.
	TIMSK1=(0<<7)|(0<<6)|(0<<ICIE1)|(0<<4)|(0<<3)|(0<<OCIE1B)|(0<<OCIE1A)|(0<<TOIE1);
	TCNT1=0x0000;
	ICR1=0x0000;
	OCR1A=0x0000;
	OCR1B=0x0000;
	sei();
	/* Replace with your application code */
	while (1)
	{
		
	}
}


