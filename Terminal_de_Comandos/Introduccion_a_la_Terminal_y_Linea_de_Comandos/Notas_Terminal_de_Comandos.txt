Para comprender la terminal de comandos se sugiere ver:
-Qué es la terminal.
-Por qué usar la terminal.
-Como usar la terminal.
-Como aprovechar la terminal al máximo.
En la pc tenemos una memoria donde de almacenan datos e instrucciones, la pc revisa periodicamente la memoria y conforme a los datos va modificando el contenido de la memoria. Para lograr que siga las instrucciones que nosotros deseamos mandarle debemos expresarlo pero ya que las computadoras no hablan, debe haber un intermediario que se encarge de eso.
La terminal de comandos es entonces la encargada de recibir nuestras instrucciones por medio de texto y de esta manera ser nuestro de medio de comunicación con la pc y el SO.
La terminal se usa en vez de una interfaz gráfica cuando se desea tener mayor eficiencia, sacrificando la parte gráfica.
Para ingresar instrucciones a través de la terminal, se usa comandos los cuales estan conformados por el nombre de un programa, parámetros y modificadores, comando -flag1 -flag2 -arg1 arg2.
El comando date nos muestra la fecha y hora actual.
Con el comando man podemos ver el manual del comando a ejecutar por ejemplo "man date".
La terminal aparte de comandos también contiene utilidades propias como combinaciones de teclas, comodines y substitución de comandos.
Al presionar las iniciales de un comando y presionando la tecla tab se nos muestran las posibilades o se autocompleta el comando a ejecutar si es el unico posible.
Al presionar las direccionales de arriba o abajo nos muestra los comandos usados en el orden en el que fueron llamados.
Con ctrl+shift+r se hace una búsqueda de un comando usado anteriormente.
Con history se muestra el historial de todos los comandos ejecutados.
Usando el signo de admiración y el número de comando del historial nos permite ejecutar ese comando ejemplo !108.
Para instalar la terminal de ubuntu en windows se debe ejecutar el comando siguiente comando en powershell: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux .
Una vez realizado esto se abre la Microsoft store y desde allí se descarga la versión deseada de ubuntu y en automático la instalará.
Para organizar la información en una pc se usan directorios y archivos, formando de tal forma el árbol de directorios.
El path se conforma por la ruta de directorios y el nombre del archivo.
Con ls se ven los archivos del directorio.
Con ls -a se ven todos los archivos incluyendo los ocultos.
Con .. se hace referencia al directorio padre y con . se hace referencia al directorio actual.
Con pwd (print working directory), se imprime el directorio actual.
Con cd se cambia al directorio que se le indique cd /home.
Con cd ~ nos manda al directorio principal o base.
Con cd - se manda al directorio anteriormente consultado.
Con mkdir se crea el directorio.
Con ls -l se listan los archivos y directorios así como sus permisos.
Con cp se copia un archivo o directorio, cd ruta_archivo_origen directorio_destino.
Con rm se borra el archivo indicado, rm ruta_archivo.
Con rmdir se borra un directorio, pero este debe estar vacío.
Lista los archivos que se encuentran en el directorio sobre el que estamos trabajando: > ls
Lista todos los archivos incluyendo aquellos que se han definido como ocultos: > ls -a
Todos los directorios contienen los archivos . y .., estos son punteros a directorios: .. --> directorio padre, . --> directorio actual.
Otros parámetros que puedes usar con el comando ls:
-Ordena los archivos por fecha de modificación: > ls -t
-Ordena elementos primero por nombre y después por extensión: > ls -x
-Ordena los elementos primero por extensión y luego por nombre: > ls -X
-Muestra toda la información: usuario, grupo, permisos, tamaño, fecha y hora de creación: > ls -l
-Muestra la misma información que ls -l pero con las unidades de tamaño en KB, MB: > ls -lh
-Muestra el contenido de todos los subdirectorios de forma recursiva: > ls -R
-Ordena los resultados por tamaño de archivo: > ls -S
Comandos para cambiar de ubicación:
-Print Working Directory: se usa para mostrar el directorio actual en el que nos encontramos trabajando: > pwd
-cd: se utiliza para cambiar de directorio. Luego del comando se debe especificar la ruta del directorio al que nos queremos mover. Por ejemplo: > cd /home/mi_usuario.
Comandos para mover, copiar o borrar:
-cp: copiar un archivo hacia un directorio: > cp [archivo que se va a copiar] [directorio hacia el que se va a mover].
-rm: eliminar un archivo: > rm archivo.txt
-mv: mover un archivo, cambiar su ubicación. La sintaxis es así: >mv [ruta del archivo] [directorio hacia el que se va a mover]
rmdir: eliminar un directorio. En este caso es importante resaltar que, para que el directorio pueda ser eliminado, no puede contener archivos u otros directorios en su interior: > rmdir [ruta / nombre del directorio a eliminar].
En la pc los archivos se guardan en binario y en archivos de texto, siendo los archivos binarios aquellos que solo pueden ser ejecutados por una pc y en programa adecuado, algunos ejemplos son documentos, executables, fotos, videos. Los archivos de texto son aquellos que al abrirse con un editor de texto pueden ser leídos por humanos ya que tienen una codificación como ascci, utf, etc, ejemplos son código fuente, configuraciones y páginas web.
En linux hay 2 editores comunes de texto vim y nano.
En Vim para empezar a editar texto se presiona la letra i, con escape se sale del modo edición y con :w se guarda el archivo y con :q se sale del editor VIM.
En nano siempre que se abre se está en modo edición y abajo aprecen los comandos para realizar diversas instrucciones como guardar, salir, buscar.
Utilidades batch o de procesamiento por lotes: Programas que procesan texto y emiten el resultado.
cat: Nos muestra el contenido completo de un archivo cat nombre_archivo.
head: Nos muestra las primeras líneas del archivo head -n #delíneas nombre_archivo. 
tail: Nos muestra las ultimas líneas del archivo tail -n #delíneas nombre_archivo.
grep: Búsqueda por expresiones regulares en el archivo.
grep Hanks dump1.sql : Busca si existe la palabra en el archivo y devuelve la línea.
grep -i hanks dump1.sql : Busca la palabra sin distinción de mayúsculas o minúsculas.
grep -i "hanks$" dump1.sql : Busca que haya una línea que termine con la palabra hanks
Sed (spread editor): Tratamiento de flujo de caracteres, nos muestra como quedaría un archivo si se remplazará una parte, pero no lo sobreescribe.
sed 's/Hanks/Selleck/g' dump1.ql : Cambia la palabra Hanks por Selleck.
sed '$d$ dump1.sql : Elimina la ultima línea del archivo.
Awk: Se usa para Tratamiento de texto delimitado, sirve para texto separado por comas, punto y coma, entre otros además que puede realizar operaciones y condicionales.
awk -F ',' '{print $1}' dump1.sql : Imprime todo lo que haya antes de la primera coma, con -F se indica el parámetro, con ',' el caracter delimitador y {print $1} indica que solo se imprime antes de la primera coma.
awk -F ';' 'NR > 1 && $3 > 0 {print $1, $3 * $4}' dump1.sql : Usa ";" como delimitador y verifica que el número de línea sea mayor a 1 que el argumento 3 de cada renglon sea mayor a 0 e imprime el argumento 1 seguido de la multiplicación del argumento 3*4.
Trabajo fundamental con archivos de texto:
- touch: nos permite crear archivos : > touch archivo.txt
- cat: nos permite visualizar todo el contenido de nuestros archivos: > cat archivo.txt
- head: es muy parecido al comando cat. También nos permite visualizar el contenido de nuestros archivos, pero debemos indicarle cuántas líneas nos debe mostrar. Por defecto nos mostrará las primeras 10: # primeras 10 líneas > head archivo.txt , # primeras 20 líneas > head -n 20 archivo.txt
tail: funciona igual que el comando head, pero al revés. También debemos indicarle cuántas líneas nos debe mostrar, la diferencia es que no las mostrará de abajo hacia arriba. Por defecto nos mostrará las últimas 10: # últimas 10 líneas > tail archivo.txt # últimas 5 líneas > tail -n 5 archivo.txt
Búsqueda y tratamiento de texto:
No solo podemos visualizar nuestros archivos (o parte de nuestros archivos) tal cual como escribimos, también podemos filtrar y cambiar el contenido que podemos ver en los archivos.
Por ejemplo: imagina que tenemos un archivo gigante, con cientos o incluso miles de líneas. Si imprimieramos el contenido de todo el archivo sería muy difícil encontrar el nombre de una persona o elemento específico.
Y se vuelve aún más complicado si necesitamos que las palabras que buscamos cumplan ciertas condiciones, como solo mayúsculas o minúsculas, que la siguiente o anterior palabra cumpla ciertas condiciones, etc.
En estos casos podemos utilizar el comando grep para filtrar las líneas que queremos visualizar utilizando (o no) expresiones regulares: > grep “palabra-clave” archivo_gigante.txt.
Si nos da igual si la palabra clave incluye mayúsculas o minúsculas podemos utilizar el flag -i: > grep -i “pAlaBra-cLAvE” archivo_gigante.txt.
También podemos verificar si la línea incluye esta palabra clave al final: > grep “palabra-clave$” archivo_gigante.txt.
O si la incluye al principio: > grep “^palabra-clave” archivo_gigante.txt.
También hay situaciones donde necesitamos modificar un poco la información que obtenemos de un archivo de texto.
Por ejemplo, imagina que nuestro archivo contiene un poema, frase o saludo para responderle a los usuarios de nuestra aplicación. El problema es que cada usuario tiene un nombre diferente. > ¡Hola, NOMBRE_USUARIO! Felicitaciones por completar tu desafío con PUNTOS_USUARIO puntos.
No queremos editar este archivo. Solo necesitamos cambiar los caracteres NOMBRE_USUARIO por el verdadero nombre del usuario.
Para esto podemos utilizar el comando sed. Solo debemos indicarle que queremos realizar una sustitución (s/), la palabra que vamos a cambiar (NOMBRE_USUARIO), la nueva palabra que vamos a incluir (Ana) y cerrar con el símbolo / : > sed ‘s/NOMBRE_USUARIO/Ana’ archivo-saludo.txt .
Ahora imagina que, además del nombre, debemos cambiar también la puntuación que obtuvo el usuario: > sed ‘s/NOMBRE_USUARIO/Ana/; s/PUNTOS_USUARIO/35/’ archivo-saludo.txt
Puedes ver muchos más usos del comando sed en este tutorial: https://likegeeks.com/es/sed-de-linux/.
El esquema más clásico de procesamiento de datos es cuando los datos ingresan a un proceso y este proceso devuelve información.
Los canales por donde ingresan los datos a proceso y por donde sale la información se conocen como flujos o frames.
En la terminal hay al menos 3 flujos estándar: Entrada Salida y Error.
Por defecto la entrada está conectada a los periféricos comunes, la entrada al teclado y la salida en el display de la consola.
Cuando la entrada de datos no proviene de una cadena de datos armada por nosotros si no por un archivo se ejecuta un proceso de redireccionamiento.
Un ejemplo de entrada por archivo es: mysql -h 121.0.0.1 -u root -p1234 < dump1.sql, con esta opción vez de pasarle todo el texto estando sujeto a errores o un proceso mas largo simplemente se le pasa un archivo que contenga los datos a procesar.
La segunda forma de redireccionamiento es usar la entrada por teclado (o por archivo) y que el resultado en vez de mostrarlo en pantalla, como con cat y gred, lo guarde en un archivo.
ls > archivos.txt : Guarda la salida de ls en el archivo.txt
ls -l >> archivo.txt : Guarda la salida de ls -l al final del archivo.txt.
Cuando se necesita un proceso mas complejo, donde la salida de un proceso es la entrada de otro y así sucesivamente hasta donde se requiera, se usan pipes (tuberías) con lo cual pasamos la salida de a la entrada de otro con "|".
cat archivo_grande.txt | more : Muestra el archivo por partes en la pantalla en vez de desplegarlo todo totalmente (con barra espaciadora muestra una nueva página y con enter una nueva línea).
cat dump1.sql | wc -l: Cuenta cuantas palabras hay en el archivo.
ls -al | more: Muestra las carpetas permitiendo avanzar por partes.
cat archivo.txt
head -n 64 matriz.c > primeraMitad.txt
tail -n 64 matriz.c > segundaMitad.txt
date >> segundaMitad.txt
sed -n 1,30p file.csv > file1.txt | date >> file1.txt | sed -n 31,80p file.csv > file2.txt
Al ejecutar cualquier comando mediante la terminal en realidad estamos lanzando un proceso, lo más comun es que ese proceso se ejecute rapidamente de tal forma que sea casi inmediata su respuesta.
Existen casos en que el proceso bloquea la terminal y no se permite ejecutar nada hasta que termine, a este tipo de ejecución se le llama ejecución en primer plano (o foreground).
Para permitir ejecutar un proceso en paralelo (segundo plano o background) se usa "&", lo que permite volver a tener el control de la terminal a pesar que el proceso se este ejecutando.
Cuando se tiene un proceso continuamente ejecutándose, como un servidor que se necesita ejecurtar continuamente para responder al cliente, estos procesos de ejecución contínua se le conocen como servicios, daemons o demonios.
Cuando proceso lanzado puede mandarse al background presionando ctrl-z y para reanudarlo se presiona fg, permitiendo asi su reanudación.
Para identificar los procesos en ejecución se puede usar ps y top.
Con "ps" se listan los procesos.
Con "ps ax" se listan todos los procesos pero con mas información acerca de cada uno de ellos.
Al ser ps una utilidad de tipo bash(manda resultado impreso en consola), se le puede agrgar un pipe para identificar lo que deseamos ver.
Con "ps ax | grep init" solo se muestran los procesos que contengan la palabra init.
Con el comando top se listan los procesos pero de una manera interactiva, con la letra "q" se sale.
Con "kill -9 NumeroPID" se termina un proceso forzosamente.
Con "killall -9 nombreComando" se termina un proceso forzosamente con su nombre de archivo.
Permisos para Usuarios, Grupos y Super Usuarios.
Nuestro trabajo consiste en limitar las acciones que pueden realizar los usuarios de nuestros sistemas. Debemos encargarnos de que los usuarios no tengan más permisos de los que deberían tener.
Todo lo que no está explícitamente permitido, debe estar explícitamente prohibido.
Cuando hablamos de permisos no solo hablamos de usuarios individuales, también hablamos de grupos y super usuarios:
-Los grupos de usuarios nos permiten darles los mismos permisos a diferentes usuarios. Todos los usuarios que pertenezcan al mismo grupo tendrán los mismos permisos. Así evitamos tener que darle los mismos permisos a cada usuario individualmente, uno por uno. Con solo cambiar los permisos del grupo cambiamos el permiso de todos los usuarios.
-También están los super usuarios, la parte más alta de la pirámide, los que pueden hacer cualquier cosa. Lo ideal no es trabajar con este tipo de usuarios, ya que podrá activar procesos o realizar tareas que afecten nuestro servidor o generar vulnerabilidades. Más bien, debemos crear usuarios para cada tarea en específico que realizamos en nuestros servidores.
Cómo funcionan los permisos:
Cuando ejecutamos el comando ls podemos ver la lista de archivos y subcarpetas de la ruta donde nos encontramos. Si usamos este comando con la opción -lh podemos ver un poco más de información: fecha de modificación, peso, usuario propietario, grupo al que es miembro este archivo y los permisos:
- drwxrw-r-- usuario grupo
- drwx------ usuario grupo
- -rwxr-xr-x usuario grupo
- -rwx------ usuario grupo
La primera letra puede ser una d para indicar que hablamos de una subcarpeta o un guion (-) cuando evaluamos archivos.
Las siguientes 9 letras debemos dividirlas en grupos de 3. El primer grupo son los permisos del usuario propietario del archivo. El segundo son los permisos del grupo al que pertenece el archivo. Y el tercero son los permisos para cualquier otro usuario del sistema operativo.
Cada grupo de 3 puede comenzar con la letra r, refiriéndose a los permisos de lectura., continuar con w para referirse a los permisos de escritura y terminar con una x para indicar los permisos de ejecución.
Si en vez de estas letras encuentras un guion (-) significa que ese usuario o grupo de usuarios no tienen ese tipo de permisos.
Estos son los permisos: -rwxr-xr-- juandc estudiantes-platzi.
- Estamos trabajando con un archivo.
- El usuario propietario es juandc.
- Este archivo pertenece al grupo de estudiantes-platzi.
- El usuario propietario (juandc) tiene permiso para todo: leer, escribir y ejecutar el archivo.
- El grupo al que pertenece el archivo solo tiene permisos para leer y ejecutar el archivo, no para editarlo.
- El resto de usuarios de sistema operativo solo tienen permisos para leer el archivo, no para escribirlo ni ejecutarlo.
Actualización de permisos y propietarios:
Para cambiar los permisos se usa y usuarios see usa chmod y chown.
- Cuando nos refiramos al usuario propietario debemos usar la letra u. Si cambiamos los permisos del grupo una g. Si queremos cambiar los permisos de cualquier otro usuario usamos la o. Y si queremos cambiar los permisos de TODOS usamos la a.
- chmod g+w archivo.txt # Añadir permisos de escritura al grupo.
- chmod o-r # Eliminar permisos de lectura a los usuarios no propietarios ni miembros del grupo al que pertenece el archivo.
- chmod a+x archivo.txt # Añadir permisos de ejecución a todos (cualquier usuario).
Asignar permisos con chmod: - = 0, x = 1, w = 2, r = 4 , rwx|rwx|rwx.
chmod 754 archivo.txt: Con esto se aginan los siguientes permisos rwx para el usuario propietario, rx en el grupo, r para todos los demas usuarios.
Ahora digamos que queremos cambiar el usuario propietario de nuestro archivo. Para esto usaremos el comando chown seguido del nuevo usuario o grupo propietario del archivo.
- sudo chown nuevo-usuario archivo.txt# Cambiar el usuario propietario.
- sudo chown :nuevo-grupo archivo.txt# Cambiar el grupo propietario.
- sudo chown nuevo-usuario:nuevo-grupo archivo.txt# Cambiar el usuario y grupo propietario.
¿Cuáles acciones y permisos puede tener un usuario sobre un archivo?
​   Lectura, Escritura y Ejecución, los permisos son poder elegir cuales de estas acciones se pueden ejecutar.
¿Todos los usuarios tienen los mismos permisos sobre todos los archivos? ¿Quiénes pueden o no trabajar con estos documentos? ¿Cómo se dividen los permisos de un archivo o carpeta?
​   No todos los usuarios tienen los mismos permisos, depende de como se hayan configurado los permisos. Pueden trabajar los que tienen el permiso asignado. Se dividen en el usuario propietario, el grupo al que pertenezca y si es externo al grupo o no.
Al hablar de usuarios y permisos en el sistema operativo, ¿qué significa un 777? ¿Deberíamos preocuparnos?
​   777 significa que todos tiene permiso de leer, escribir y ejecutar un archivo, puede ser peligroso si es un archivo importante del SO, ya que se puede modificar incorrectamente causando errores o ejecutarlo cuando no es debido.
¿Que permisos debes tener para poder editar un archivo que creo otro usuario de tu sistema operativo?
​   El permiso xxrw- que sería xx6 o x6x si ese usuario pertenece al mismo grupo del usuario propietario del archivo.
¿Con qué comando cambiamos los permisos que tienen los usuarios para trabajar con un archivo?
​   Con chmod
No quieres que nadie pueda editar ni mucho menos ejecutar un script muy peligroso que estás creando. ¿Qué permisos debe tener este script para conseguir este resultado?
    En teoría solo se debería quitar w y x, pero al poderse copiar ese archivo en uno nuevo sería recomendable tambien quitar r, quedando 700.
¿Quién es sudo? ¿Es peligroso?
    Sudo es el superusuario del sistema operativo sirve para ejecutar comandos que requieren de todos los permisos. Puede ser peligroso si se deja al alcance de cualquiera ya que da acceso total a las configuraciones y puede desactivar la seguridad.