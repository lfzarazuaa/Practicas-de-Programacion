Para comprender la terminal de comandos se sugiere ver:
-Qué es la terminal.
-Por qué usar la terminal.
-Como usar la terminal.
-Como aprovechar la terminal al máximo.
En la pc tenemos una memoria donde de almacenan datos e instrucciones, la pc revisa periodicamente la memoria y conforme a los datos va modificando el contenido de la memoria. Para lograr que siga las instrucciones que nosotros deseamos mandarle debemos expresarlo pero ya que las computadoras no hablan, debe haber un intermediario que se encarge de eso.
La terminal de comandos es entonces la encargada de recibir nuestras instrucciones por medio de texto y de esta manera ser nuestro de medio de comunicación con la pc y el SO.
La terminal se usa en vez de una interfaz gráfica cuando se desea tener mayor eficiencia, sacrificando la parte gráfica.
Para ingresar instrucciones a través de la terminal, se usa comandos los cuales estan conformados por el nombre de un programa, parámetros y modificadores, comando -flag1 -flag2 -arg1 arg2.
El comando date nos muestra la fecha y hora actual.
Con el comando man podemos ver el manual del comando a ejecutar por ejemplo "man date".
La terminal aparte de comandos también contiene utilidades propias como combinaciones de teclas, comodines y substitución de comandos.
Al presionar las iniciales de un comando y presionando la tecla tab se nos muestran las posibilades o se autocompleta el comando a ejecutar si es el unico posible.
Al presionar las direccionales de arriba o abajo nos muestra los comandos usados en el orden en el que fueron llamados.
Con ctrl+shift+r se hace una búsqueda de un comando usado anteriormente.
Con history se muestra el historial de todos los comandos ejecutados.
Usando el signo de admiración y el número de comando del historial nos permite ejecutar ese comando ejemplo !108.
Para instalar la terminal de ubuntu en windows se debe ejecutar el comando siguiente comando en powershell: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux .
Una vez realizado esto se abre la Microsoft store y desde allí se descarga la versión deseada de ubuntu y en automático la instalará.
Para organizar la información en una pc se usan directorios y archivos, formando de tal forma el árbol de directorios.
El path se conforma por la ruta de directorios y el nombre del archivo.
Con ls se ven los archivos del directorio.
Con ls -a se ven todos los archivos incluyendo los ocultos.
Con .. se hace referencia al directorio padre y con . se hace referencia al directorio actual.
Con pwd (print working directory), se imprime el directorio actual.
Con cd se cambia al directorio que se le indique cd /home.
Con cd ~ nos manda al directorio principal o base.
Con cd - se manda al directorio anteriormente consultado.
Con mkdir se crea el directorio.
Con ls -l se listan los archivos y directorios así como sus permisos.
Con cp se copia un archivo o directorio, cd ruta_archivo_origen directorio_destino.
Con rm se borra el archivo indicado, rm ruta_archivo.
Con rmdir se borra un directorio, pero este debe estar vacío.
Lista los archivos que se encuentran en el directorio sobre el que estamos trabajando: > ls
Lista todos los archivos incluyendo aquellos que se han definido como ocultos: > ls -a
Todos los directorios contienen los archivos . y .., estos son punteros a directorios: .. --> directorio padre, . --> directorio actual.
Otros parámetros que puedes usar con el comando ls:
-Ordena los archivos por fecha de modificación: > ls -t
-Ordena elementos primero por nombre y después por extensión: > ls -x
-Ordena los elementos primero por extensión y luego por nombre: > ls -X
-Muestra toda la información: usuario, grupo, permisos, tamaño, fecha y hora de creación: > ls -l
-Muestra la misma información que ls -l pero con las unidades de tamaño en KB, MB: > ls -lh
-Muestra el contenido de todos los subdirectorios de forma recursiva: > ls -R
-Ordena los resultados por tamaño de archivo: > ls -S
Comandos para cambiar de ubicación:
-Print Working Directory: se usa para mostrar el directorio actual en el que nos encontramos trabajando: > pwd
-cd: se utiliza para cambiar de directorio. Luego del comando se debe especificar la ruta del directorio al que nos queremos mover. Por ejemplo: > cd /home/mi_usuario.
Comandos para mover, copiar o borrar:
-cp: copiar un archivo hacia un directorio: > cp [archivo que se va a copiar] [directorio hacia el que se va a mover].
-rm: eliminar un archivo: > rm archivo.txt
-mv: mover un archivo, cambiar su ubicación. La sintaxis es así: >mv [ruta del archivo] [directorio hacia el que se va a mover]
rmdir: eliminar un directorio. En este caso es importante resaltar que, para que el directorio pueda ser eliminado, no puede contener archivos u otros directorios en su interior: > rmdir [ruta / nombre del directorio a eliminar].
En la pc los archivos se guardan en binario y en archivos de texto, siendo los archivos binarios aquellos que solo pueden ser ejecutados por una pc y en programa adecuado, algunos ejemplos son documentos, executables, fotos, videos. Los archivos de texto son aquellos que al abrirse con un editor de texto pueden ser leídos por humanos ya que tienen una codificación como ascci, utf, etc, ejemplos son código fuente, configuraciones y páginas web.
En linux hay 2 editores comunes de texto vim y nano.
En Vim para empezar a editar texto se presiona la letra i, con escape se sale del modo edición y con :w se guarda el archivo y con :q se sale del editor VIM.
En nano siempre que se abre se está en modo edición y abajo aprecen los comandos para realizar diversas instrucciones como guardar, salir, buscar.
Utilidades batch o de procesamiento por lotes: Programas que procesan texto y emiten el resultado.
cat: Nos muestra el contenido completo de un archivo cat nombre_archivo.
head: Nos muestra las primeras líneas del archivo head -n #delíneas nombre_archivo. 
tail: Nos muestra las ultimas líneas del archivo tail -n #delíneas nombre_archivo.
grep: Búsqueda por expresiones regulares en el archivo.
grep Hanks dump1.sql : Busca si existe la palabra en el archivo y devuelve la línea.
grep -i hanks dump1.sql : Busca la palabra sin distinción de mayúsculas o minúsculas.
grep -i "hanks$" dump1.sql : Busca que haya una línea que termine con la palabra hanks
Sed (spread editor): Tratamiento de flujo de caracteres, nos muestra como quedaría un archivo si se remplazará una parte, pero no lo sobreescribe.
sed 's/Hanks/Selleck/g' dump1.ql : Cambia la palabra Hanks por Selleck.
sed '$d$ dump1.sql : Elimina la ultima línea del archivo.
Awk: Se usa para Tratamiento de texto delimitado, sirve para texto separado por comas, punto y coma, entre otros además que puede realizar operaciones y condicionales.
awk -F ',' '{print $1}' dump1.sql : Imprime todo lo que haya antes de la primera coma, con -F se indica el parámetro, con ',' el caracter delimitador y {print $1} indica que solo se imprime antes de la primera coma.
awk -F ';' 'NR > 1 && $3 > 0 {print $1, $3 * $4}' dump1.sql : Usa ";" como delimitador y verifica que el número de línea sea mayor a 1 que el argumento 3 de cada renglon sea mayor a 0 e imprime el argumento 1 seguido de la multiplicación del argumento 3*4.
Trabajo fundamental con archivos de texto:
- touch: nos permite crear archivos : > touch archivo.txt
- cat: nos permite visualizar todo el contenido de nuestros archivos: > cat archivo.txt
- head: es muy parecido al comando cat. También nos permite visualizar el contenido de nuestros archivos, pero debemos indicarle cuántas líneas nos debe mostrar. Por defecto nos mostrará las primeras 10: # primeras 10 líneas > head archivo.txt , # primeras 20 líneas > head -n 20 archivo.txt
tail: funciona igual que el comando head, pero al revés. También debemos indicarle cuántas líneas nos debe mostrar, la diferencia es que no las mostrará de abajo hacia arriba. Por defecto nos mostrará las últimas 10: # últimas 10 líneas > tail archivo.txt # últimas 5 líneas > tail -n 5 archivo.txt
Búsqueda y tratamiento de texto:
No solo podemos visualizar nuestros archivos (o parte de nuestros archivos) tal cual como escribimos, también podemos filtrar y cambiar el contenido que podemos ver en los archivos.
Por ejemplo: imagina que tenemos un archivo gigante, con cientos o incluso miles de líneas. Si imprimieramos el contenido de todo el archivo sería muy difícil encontrar el nombre de una persona o elemento específico.
Y se vuelve aún más complicado si necesitamos que las palabras que buscamos cumplan ciertas condiciones, como solo mayúsculas o minúsculas, que la siguiente o anterior palabra cumpla ciertas condiciones, etc.
En estos casos podemos utilizar el comando grep para filtrar las líneas que queremos visualizar utilizando (o no) expresiones regulares: > grep “palabra-clave” archivo_gigante.txt.
Si nos da igual si la palabra clave incluye mayúsculas o minúsculas podemos utilizar el flag -i: > grep -i “pAlaBra-cLAvE” archivo_gigante.txt.
También podemos verificar si la línea incluye esta palabra clave al final: > grep “palabra-clave$” archivo_gigante.txt.
O si la incluye al principio: > grep “^palabra-clave” archivo_gigante.txt.
También hay situaciones donde necesitamos modificar un poco la información que obtenemos de un archivo de texto.
Por ejemplo, imagina que nuestro archivo contiene un poema, frase o saludo para responderle a los usuarios de nuestra aplicación. El problema es que cada usuario tiene un nombre diferente. > ¡Hola, NOMBRE_USUARIO! Felicitaciones por completar tu desafío con PUNTOS_USUARIO puntos.
No queremos editar este archivo. Solo necesitamos cambiar los caracteres NOMBRE_USUARIO por el verdadero nombre del usuario.
Para esto podemos utilizar el comando sed. Solo debemos indicarle que queremos realizar una sustitución (s/), la palabra que vamos a cambiar (NOMBRE_USUARIO), la nueva palabra que vamos a incluir (Ana) y cerrar con el símbolo / : > sed ‘s/NOMBRE_USUARIO/Ana’ archivo-saludo.txt .
Ahora imagina que, además del nombre, debemos cambiar también la puntuación que obtuvo el usuario: > sed ‘s/NOMBRE_USUARIO/Ana/; s/PUNTOS_USUARIO/35/’ archivo-saludo.txt
Puedes ver muchos más usos del comando sed en este tutorial: https://likegeeks.com/es/sed-de-linux/.
El esquema más clásico de procesamiento de datos es cuando los datos ingresan a un proceso y este proceso devuelve información.
Los canales por donde ingresan los datos a proceso y por donde sale la información se conocen como flujos o frames.
En la terminal hay al menos 3 flujos estándar: Entrada Salida y Error.
Por defecto la entrada está conectada a los periféricos comunes, la entrada al teclado y la salida en el display de la consola.
Cuando la entrada de datos no proviene de una cadena de datos armada por nosotros si no por un archivo se ejecuta un proceso de redireccionamiento.
Un ejemplo de entrada por archivo es: mysql -h 121.0.0.1 -u root -p1234 < dump1.sql, con esta opción vez de pasarle todo el texto estando sujeto a errores o un proceso mas largo simplemente se le pasa un archivo que contenga los datos a procesar.
La segunda forma de redireccionamiento es usar la entrada por teclado (o por archivo) y que el resultado en vez de mostrarlo en pantalla, como con cat y gred, lo guarde en un archivo.
ls > archivos.txt : Guarda la salida de ls en el archivo.txt
ls -l >> archivo.txt : Guarda la salida de ls -l al final del archivo.txt.
Cuando se necesita un proceso mas complejo, donde la salida de un proceso es la entrada de otro y así sucesivamente hasta donde se requiera, se usan pipes (tuberías) con lo cual pasamos la salida de a la entrada de otro con "|".
cat archivo_grande.txt | more : Muestra el archivo por partes en la pantalla en vez de desplegarlo todo totalmente (con barra espaciadora muestra una nueva página y con enter una nueva línea).
cat dump1.sql | wc -l: Cuenta cuantas palabras hay en el archivo.
ls -al | more: Muestra las carpetas permitiendo avanzar por partes.
cat archivo.txt
head -n 64 matriz.c > primeraMitad.txt
tail -n 64 matriz.c > segundaMitad.txt
date >> segundaMitad.txt
sed -n 1,30p file.csv > file1.txt | date >> file1.txt | sed -n 31,80p file.csv > file2.txt
Al ejecutar cualquier comando mediante la terminal en realidad estamos lanzando un proceso, lo más comun es que ese proceso se ejecute rapidamente de tal forma que sea casi inmediata su respuesta.
Existen casos en que el proceso bloquea la terminal y no se permite ejecutar nada hasta que termine, a este tipo de ejecución se le llama ejecución en primer plano (o foreground).
Para permitir ejecutar un proceso en paralelo (segundo plano o background) se usa "&", lo que permite volver a tener el control de la terminal a pesar que el proceso se este ejecutando.
Cuando se tiene un proceso continuamente ejecutándose, como un servidor que se necesita ejecurtar continuamente para responder al cliente, estos procesos de ejecución contínua se le conocen como servicios, daemons o demonios.
Cuando proceso lanzado puede mandarse al background presionando ctrl-z y para reanudarlo se presiona fg, permitiendo asi su reanudación.
Para identificar los procesos en ejecución se puede usar ps y top.
Con "ps" se listan los procesos.
Con "ps ax" se listan todos los procesos pero con mas información acerca de cada uno de ellos.
Al ser ps una utilidad de tipo bash(manda resultado impreso en consola), se le puede agrgar un pipe para identificar lo que deseamos ver.
Con "ps ax | grep init" solo se muestran los procesos que contengan la palabra init.
Con el comando top se listan los procesos pero de una manera interactiva, con la letra "q" se sale.
Con "kill -9 NumeroPID" se termina un proceso forzosamente.
Con "killall -9 nombreComando" se termina un proceso forzosamente con su nombre de archivo.
Permisos para Usuarios, Grupos y Super Usuarios.
Nuestro trabajo consiste en limitar las acciones que pueden realizar los usuarios de nuestros sistemas. Debemos encargarnos de que los usuarios no tengan más permisos de los que deberían tener.
Todo lo que no está explícitamente permitido, debe estar explícitamente prohibido.
Cuando hablamos de permisos no solo hablamos de usuarios individuales, también hablamos de grupos y super usuarios:
-Los grupos de usuarios nos permiten darles los mismos permisos a diferentes usuarios. Todos los usuarios que pertenezcan al mismo grupo tendrán los mismos permisos. Así evitamos tener que darle los mismos permisos a cada usuario individualmente, uno por uno. Con solo cambiar los permisos del grupo cambiamos el permiso de todos los usuarios.
-También están los super usuarios, la parte más alta de la pirámide, los que pueden hacer cualquier cosa. Lo ideal no es trabajar con este tipo de usuarios, ya que podrá activar procesos o realizar tareas que afecten nuestro servidor o generar vulnerabilidades. Más bien, debemos crear usuarios para cada tarea en específico que realizamos en nuestros servidores.
Cómo funcionan los permisos:
Cuando ejecutamos el comando ls podemos ver la lista de archivos y subcarpetas de la ruta donde nos encontramos. Si usamos este comando con la opción -lh podemos ver un poco más de información: fecha de modificación, peso, usuario propietario, grupo al que es miembro este archivo y los permisos:
- drwxrw-r-- usuario grupo
- drwx------ usuario grupo
- -rwxr-xr-x usuario grupo
- -rwx------ usuario grupo
La primera letra puede ser una d para indicar que hablamos de una subcarpeta o un guion (-) cuando evaluamos archivos.
Las siguientes 9 letras debemos dividirlas en grupos de 3. El primer grupo son los permisos del usuario propietario del archivo. El segundo son los permisos del grupo al que pertenece el archivo. Y el tercero son los permisos para cualquier otro usuario del sistema operativo.
Cada grupo de 3 puede comenzar con la letra r, refiriéndose a los permisos de lectura., continuar con w para referirse a los permisos de escritura y terminar con una x para indicar los permisos de ejecución.
Si en vez de estas letras encuentras un guion (-) significa que ese usuario o grupo de usuarios no tienen ese tipo de permisos.
Estos son los permisos: -rwxr-xr-- juandc estudiantes-platzi.
- Estamos trabajando con un archivo.
- El usuario propietario es juandc.
- Este archivo pertenece al grupo de estudiantes-platzi.
- El usuario propietario (juandc) tiene permiso para todo: leer, escribir y ejecutar el archivo.
- El grupo al que pertenece el archivo solo tiene permisos para leer y ejecutar el archivo, no para editarlo.
- El resto de usuarios de sistema operativo solo tienen permisos para leer el archivo, no para escribirlo ni ejecutarlo.
Actualización de permisos y propietarios:
Para cambiar los permisos se usa y usuarios see usa chmod y chown.
- Cuando nos refiramos al usuario propietario debemos usar la letra u. Si cambiamos los permisos del grupo una g. Si queremos cambiar los permisos de cualquier otro usuario usamos la o. Y si queremos cambiar los permisos de TODOS usamos la a.
- chmod g+w archivo.txt # Añadir permisos de escritura al grupo.
- chmod o-r # Eliminar permisos de lectura a los usuarios no propietarios ni miembros del grupo al que pertenece el archivo.
- chmod a+x archivo.txt # Añadir permisos de ejecución a todos (cualquier usuario).
Asignar permisos con chmod: - = 0, x = 1, w = 2, r = 4 , rwx|rwx|rwx.
chmod 754 archivo.txt: Con esto se aginan los siguientes permisos rwx para el usuario propietario, rx en el grupo, r para todos los demas usuarios.
Ahora digamos que queremos cambiar el usuario propietario de nuestro archivo. Para esto usaremos el comando chown seguido del nuevo usuario o grupo propietario del archivo.
- sudo chown nuevo-usuario archivo.txt# Cambiar el usuario propietario.
- sudo chown :nuevo-grupo archivo.txt# Cambiar el grupo propietario.
- sudo chown nuevo-usuario:nuevo-grupo archivo.txt# Cambiar el usuario y grupo propietario.
¿Cuáles acciones y permisos puede tener un usuario sobre un archivo?
​   Lectura, Escritura y Ejecución, los permisos son poder elegir cuales de estas acciones se pueden ejecutar.
¿Todos los usuarios tienen los mismos permisos sobre todos los archivos? ¿Quiénes pueden o no trabajar con estos documentos? ¿Cómo se dividen los permisos de un archivo o carpeta?
​   No todos los usuarios tienen los mismos permisos, depende de como se hayan configurado los permisos. Pueden trabajar los que tienen el permiso asignado. Se dividen en el usuario propietario, el grupo al que pertenezca y si es externo al grupo o no.
Al hablar de usuarios y permisos en el sistema operativo, ¿qué significa un 777? ¿Deberíamos preocuparnos?
​   777 significa que todos tiene permiso de leer, escribir y ejecutar un archivo, puede ser peligroso si es un archivo importante del SO, ya que se puede modificar incorrectamente causando errores o ejecutarlo cuando no es debido.
¿Que permisos debes tener para poder editar un archivo que creo otro usuario de tu sistema operativo?
​   El permiso xxrw- que sería xx6 o x6x si ese usuario pertenece al mismo grupo del usuario propietario del archivo.
¿Con qué comando cambiamos los permisos que tienen los usuarios para trabajar con un archivo?
​   Con chmod
No quieres que nadie pueda editar ni mucho menos ejecutar un script muy peligroso que estás creando. ¿Qué permisos debe tener este script para conseguir este resultado?
    En teoría solo se debería quitar w y x, pero al poderse copiar ese archivo en uno nuevo sería recomendable tambien quitar r, quedando 700.
¿Quién es sudo? ¿Es peligroso?
    Sudo es el superusuario del sistema operativo sirve para ejecutar comandos que requieren de todos los permisos. Puede ser peligroso si se deja al alcance de cualquiera ya que da acceso total a las configuraciones y puede desactivar la seguridad.
Para descargar un programa primero se debe identificar la dirección de donde se descargará seguido de la descarga, luego copiar los archivos y hacer una configuración para instalarlo.
Existen programas que realizan todas las tareas involucradas en la instalación estas se llamann paquetes de software.
Los administradores de paquetes son los programas que conocen de donde descargar, cuales programas ya han sido descargados y como configurar todo de tal forma que no hayan conflictos, un ejemplo es cuando un paquete depende de otro paquete y la terminal no los informa.
Existen varios manejadores de paquetes apt para distribuciones basadas en debian, zypper para suse y rpm es mas universal pero rústico.
Un ejemplo es sudo apt install lynx: Para instalar lynx dentro de linux.
lynx platzi.com :Se puede acceder a una versión en terminal de la página web solicitada.
Para poder instalar paquetes o librerías para programas en especial se usan paquetes de lenguajes, estos son paquetes escritos en el mismo lenguaje a usar.
pip - administrador de paquetes en python.
sudo pip install pandas :Instala la librería pandas de python.
composer - administrador de paquetes en php.
npm - administrador de paquetes en node.js
conda y homebrow son otros administradores de paquetes pero se necesitan instalar primero estos administradores desde la terminal.
https://itsfoss.com/apt-vs-apt-get-difference/
ls archivo -lh: Para ver el tamaño del archivo.
Una utilidad para comprimir archivos es gzip.
gzip archivo.txt: Comprime el archivo dando un archivo.txt.gz.
gzip -d archivo.txt.gz: Descomprime el archivo dando un archivo.txt.
Cuando se necesita combinar archivos en uno solo se puede usar la utilidad tar.
tar cf backup.tar backup/*: Crea un archivo que contiene a los de la carpeta con el nombre backup.tar, pero sin comprimir cf(create file).
tar tf backup.tar: Lista los archivos dentro del .tar.
tar xf backup.tar: Restaura los archivos contenidos.
tar czf backup.tar backup/*: Comprime la carpeta en un archivo backup.tar.
tar xzf backup.tar: Descomprime la carpeta.
GZIP - Compresión y Descompresión de archivos
gzip [nombreArchivo] - comprime archivo generando un .gz
gzip -d [nombreArchivo] -descomprime
TAR - Agrupación y compresión de archivos
tar cf archivo.tar [listadoArchivos] -> Agrupa los archivos
tar tf archivo.tar -> lista los archivos dentro del agrupamiento
tar xf archivo.tar -> desagrupa los archivos
tar czf archivo.tgz [fichero] -> agrupa y comprime
tar xzf archivo.tgz -> descomprime y desagrupa
locate - Permite hacer una búsqueda en todo el sistema de archivo, mediante una búsqueda en una base de datos.
sudo updatedb - Actualiza la base de datos de los directorios. Siempre es conveniente ejecutar este comando primero.
locate [nombreArchivo] - busca el archivo y devuelve el path del archivo.
whereis - Permite buscar archivos binarios (es decir, comandos)
whereis [nombreComando] - busca los binarios y devuelve el path de donde esta el comando.
find - Buscar dentro de un árbol de directorio, mediante una serie de criterio, es la mas complejo.
find . -user luis Busca archivos que su usuario propietario sea luis
find . -user luis -perm 664 Busca archivos que su propietario sea luis y que tengan permisos de 664 rw-rw-r--.
find . -type f Que devuelva solo archivos.
find . -type f -mtime +7 Que devuelva solo archivos y que hayan sido actualizados hace más de 7 días.
find . -type f -mtime +7 -exec cp {} ./backup/; Copia a Backup aquellos archivos que hayan sido actualizados hace más de 7 días.
Con curl y con wget se pueden realizar consultas http.
https://www.solvetic.com/tutoriales/article/5925-como-usar-y-ejemplos-comando-curl-linux/
curl https://platzi.com : Se envia el html que interpreta el navegador.
curl -v https://platzi.com : Se envia el html que interpreta el navegador adicionando los headers http.
curl -v https://platzi.com > dev/null: Se manda a escribir a dev/null, de tal forma evitando generar un archivo pero se queda con los headers.
wget https://media-exp1.licdn.com/dms/image/C4D0BAQEnKdGryPPiJw/company-logo_100_100/0?e=1599696000&v=beta&t=eFBZ-22hPnJ-fFH5GMFSTmUG4ByUYxFze9FOtWld830 : Obtiene el recurso (archivo) y lo guarda en la pc.
Con ssh se puede controlar una terminal remota, si no se tienen llaves se necesitan ingresar las contraseñas y el usuario.
https://www.hostinger.es/tutoriales/que-es-ssh
https://computingforgeeks.com/install-and-configure-openssh-server-on-windows-server/
ssh nombre de usuario@ host (host puede ser ip)
ingresar contraseña
Para envío de mail por la terminal se una postfix en conjunto con mailutils.
sudo DEBIAN_PRIORITY=low apt install postfix.
Configuración de correo en "sitio de internet".
Dejar en blanco nombre del sistema de correo.
En recipiente de correo para el administrador se ingresa el correo electrónico.
En otros destinos para los cuales aceptar correo se deja en blanco.
En forzar las actualizaciones díncronas en la cola de correo se presiona no.
En redes locales: se deja en blanco.
En límite del tamaño de buzón del correo se deja en blanco (predeterminado).
En el carácter de extensión de direcciones locales se deja en blanco.
En protocolos de internet a usar se coloca todos (ipv6 e ipv4).
Luego se procede a instalar mailutils.
sudo apt install mailutils
echo “Hola Mundo!” | mail -s “Testing” TU_EMAIL: Envia un email.
https://www.linode.com/docs/email/postfix/configure-postfix-to-send-mail-using-gmail-and-google-apps-on-debian-or-ubuntu/
Un comando es el nombre de un programa y sus modificadores, siendo el nombre de un programa el nombre de un archivo, pero al momento de ejecutarlo no es necesario llamar a toda su ruta en la terminal.
Para poder ejecutar ciertos comandos se usan las variables de entorno de donde se pueden obtener las rutas de los programas.
La variable de entorno utilizada para llamar a cada programa correctamente es la variable $PATH, aquí se almacenan todas las rutas de archivos ejecutables en la dirección /usr/bin/.
Para mostrar el contenido de una variable se usa echo $PATH, para mostrar solo el nombre de la variable se usa echo PATH.
Las variables de entorno se pueden asignar para un comando en particular o para toda la sesión.
Para toda la sesión se usa export Variable=valor, export num1="uno".
Para una asignanción particular se usa VAR=valor comando, ejecutarciclo=/cadena php ciclo.
alias mi_comando = ls -al: Crea un alias para llamar a las instrucciones ls -al.
mi_comando prueba.txt: Uso del alias.
https://alvinalexander.com/blog/post/linux-unix/create-aliases/
