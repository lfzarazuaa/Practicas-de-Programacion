.Net framework comenzó con su versión 1.0 (2002) y evolucionó a la versión 1.1(2003) sin embargo no fue lo que se esperaba.
El framework .net 2.0 (2005) fue un inició casi desde cero, convirtiéndose en el núcleo hasta el framework 4.8 donde aun no era multiplataforma.
Con .net Core 1.0 (2016) se logró evolucionar el framework a uno multiplataforma (varios S.0.), el framework .net core 3.1 (2019) sera modificado a un framework universal llamado .net 5 (2020).
Con blazor podemos trabajar del lado del cliente sin necesidad de conectarse al servidor, similar a lo que hace javascript.
Con blazor se hace un proceso mas rápido, mejora la experiencia de usuario y en el desarrollo.
Blazor Server y  WebAssembly(Blazor Client Server).
En Blazor Server se comunica el cliente con el servidor para realizar las peticiones mientras que en WebAssembly todo se maneja del lado del cliente.
Blazor Server se basa en Signal R el cual usa websockets para trabajar información en tiempo real, proporcionando compatibilidad para hospedar componentes de Razor en el servidor en una aplicación ASP.NET Core.
https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-3.1
Dependencias: Estructuras de código y librerías para utilizar en nuestra aplicación, se divide en analizadores y frameworks.
Las propiedades son los settings generales que utiliza nuestra aplicación, se dice sobre que puerto trabajará bajo que dirección y con que herramienta se ejecutará.
En la carpeta Data es donde se realiza el llamado a los datos de nuestra aplicación para posteriormente cargarlos.
En pages viene como se veran las páginas en cuanto a su parte visual (html).
Host es la página principal sobre la cual se monta toda la estructura.
En el import se cargan todos los espacios de nombre necesarios a la aplicación.
En shared se cargan las plantillas a usar.
Program es un archivo en .net en donde se indica cual es la estructura de inicio, por default es Startup (archivo de configuración).
En Startup se dice toda la configuración para arrancar, carga RazorPages, ServerSideBlazor y Singleton.
En wwwroot se llaman todos los estilos (css).
Las páginas con componentes Razor tienen una extensión .razor.
Cada página tiene una estructura llamada enrutado, nos permite organizar toda la información de acuerdo a los parámetros que queremos darle @page "/counter".
Para realizar el enrutamiento a la pagina por defecto se usa @page "/" la cual nos lleva al index por defecto.
@code{} //Para indicar que habra código en c#.
Razor nos permite combinar código del lado del cliente con código del lado del lado del servidor.
<div> //Llama un código del lado del servidor sin recargar.
    @message
</div>
@code{
    string message = "Un contenido.";
}

<input type="text" value="@message"/> //Relaciona el valor del input con la variable pero solo lo lee una vez.
Con bind se lográ vincular la información para que se actualice ya sea por código o por interacción con el usuario.
//Código para leer un formulario con razor.
<input type="text" @bind-value="@message"/> Comunicación bidireccional con la variable.
<input type="text" @bind-value="@message1" />
<br/>
<input type="text" @bind-value="@message2" />
<br/>
<input type="button" value="Haga clic aqui" @onclick="ChangeText" />
<div>
    <p>Mensaje 1: @messageInp1</p>
    <p>Mensaje 2: @messageInp2</p>
</div>

@code{
    string message1 = "Un contenido A";
    string message2 = "Un contenido B";
    string messageInp1 = "";
    string messageInp2 = "";
    private void ChangeText()
    {
        messageInp1 = message1;
        messageInp2 = message2;
    }
}
En _Imports.razor se carga la ruta relativa de la carpeta de donde tenemos las páginas que queremos mandar a llamar, esto para lograr cargarlas desde otra parte y asi tener un mejor control sobre el archivo.
[Parameter] //Declaración de un parámetro.
    public string Message { get; set; } //Parámetro por defecto público para poder ingresar datos con una misma estructura.
protected override async Task OnInitializedAsync() //Transfiere el parámetro justo cuando se cargó el html.
{
    message = Message;//Se actualiza el mensaje cuando se crea el componente.
}