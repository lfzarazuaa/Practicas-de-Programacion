JavaScript es un lenguaje debilmente típado.
Al ser debilmente típado una variable puede ser reasignada con otro tipo de dato al de origen.
var primeraLetraDelNombre = nombre.charAt(0);//Extraer la posición cero del String.
var nombreCompleto =`${nombre} ${apellido.toUpperCase()}`;//Notación para interpolar variables.
var str = nombre.charAt(1,3);//Nos devuelve el substring.
JavaScript por defecto no es tan preciso con los números se le debe especificar el tipo de dato o incluir alguna Biblioteca como Math.
function imprimirEdad(nombre, edad) {//Declaración de función.
   console.log(`${nombre} tiene ${edad} años`);
}
imprimirEdad(25, "Carlos");//Javascript no le encuentra sentido al tipo de datos si no se le específica.
imprimirEdad();//Sin párametros nos deja las variables con valor undefined.
El entorno donde se guardan las variables globales es window.
En Javascript se permite trabajar en ámbito local y global.
//Función para recibir objetos por parametros.
function imprimirNombreEnMayusculas({ nombre }){//Del objeto que se le pase obtiene el atributo nombre.
   console.log(nombre.toUpperCase());//Imprime el nombre en consola.
}
imprimirNombreEnMayusculas({nombre: "Pepito"})//Llamada a función cuando se le pasa el objeto sin declarar una variable.
Un atributo se compone de una clave (key) y un valor (value), que se separan entre sí por dos puntos “”:"". Los valores pueden ser de tipo string, número, booleano, etc. Cada atributo está separado del siguiente por una coma. Un objeto puede tener todos los atributos que sean necesarios.
Escribir el nombre de un objeto separado por un punto del nombre de un atributo, nos permite acceder al valor de dicho atributo para ese objeto. Un objeto también se puede pasar como atributo en una función.
Las últimas versiones de JavaScript nos permiten desglosar el objeto para acceder únicamente al atributo que nos interesa. Esto se consigue encerrando el nombre del atributo entre llaves { }.
var { nombre } = persona;//Desestructra el objeto, creando una variable local nombre que contiene el valor del nombre de la persona.
En JavaScript los objetos que se pasan por párametro son tomados por referenia(a la misma localidad de memoria del objeto).
function sumarEdadEnObjetoNuevo(persona) {//Paso de objeto sin modificar su valor.
   return{
      ...persona,//Crea una copia en memoria del objeto.
      edad: persona.edad + 1//Sobrescribe el valor del atributo edad.
   }
}
Para comparar haciendo una conversión automatica del tipo de dato (para que sean iguales) se usa ==, 4=="4"
Para comparar incluyendo el tipo de dato 4==="4".
Cuando realizamos operaciones es recomendable usar tres símbolos de igual (===). Esto permite que JavasScript no iguale las variables que son de distinto tipo. Te recomendamos que uses el triple igual siempre que estés comparando variables.
Para que un valor no pueda ser modificado una vez despues de ser asignado se usa la palabra reservada const.
Compo buena práctica las constantes se escriben todas en mayúsculas.
const esMayorDeEdad = ({ edad }) => edad >= MAYORIA_DE_EDAD //Declaración de una arrow function en una sola línea.
toFixed(1) //Para fijar cuantos decimales queremos.
Con la palabra reservada debugger se realiza un breakpoint en el código.
Switch se recomienda usar cuando se tienen muchos casos que verifican la misma variable.
Javascript permite mezclar distintos elementos en un array.
personas[2]['altura']//Obtiene la altura de la persona con índice 2.
const esAlta = persona => {//Arrow function.
  return persona.altura > 1.8
}
var personasAltas = personas.filter(esAlta)//Filtra todas las personas que cimplen con la condición.
Con la función map nos devuelve un nuevo array, pero si no somos cuidadosos en la forma de editarlo tambien lo cambiaremos.
const pasarAlturaACms = persona => ({//Se usan los () para encerrar el objeto que se devuelve.
  ...persona,
  altura: persona.altura * 100
})

var personasCms = personas.map(pasarAlturaACms)
El método reduce() nos permite reducir, mediante una función que se aplica a cada uno de los elemento del array, todos los elementos de dicho array, a un valor único.
const reducer = (acum, { cantidadDeLibros }) => acum + cantidadDeLibros
var totalDeLibros = personas.reduce(reducer, 0)
Los clases JavaScript son mas parecidos a prototipos, ya que no existe la herencia como tal.
Al crear una instancia de una función ya se esta creando un nuevo objeto.
La función al llamarse con new actua como un constructor de una clase.
Si no se usa la palabra reservada new se tendra que construir el prototipo del objeto en la función y regresarlo como respuesta.
Las clases son funciones cuya sintaxis tiene dos componentes:
- expresiones
- declaraciones
function Persona(nombre, apellido, altura) {//Declaración de clase.
  this.nombre = nombre;
  this.apellido = apellido;
  this.altura = altura;
}

Persona.prototype.saludar = function () {//Declaración del método de una clase.
  console.log(`Hola, me llamo ${this.nombre} ${this.apellido}`)
}

En prototipos con arrow function this ya no hace referencia al objeto.
This en arrow function hace referencia al this del scope global, apuntando asi al objeto window.
En JavaScript solo existe la herencia prototipal.
Los objetos en JavaScript son “contenedores” dinámicos de propiedades. Estos objetos poseen un enlace a un objeto prototipo. Cuando intentamos acceder a la propiedad de un objeto, la propiedad no sólo se busca en el propio objeto sino también en el prototipo del objeto, en el prototipo del prototipo, y así sucesivamente hasta que se encuentre una propiedad que coincida con el nombre o se alcance el final de la cadena de prototipos.
Todas las funciones tienen el atributo prototype y nos dice cual es el constructor y que métodos tiene.
La palabra __proto__ nos dice como está definida la herencia prototipal en un objeto.
function heredaDe(prototipoHijo, prototipoPadre) {
  var fn = function () {}//Declara la función a sobreescribir.
  fn.prototype = prototipoPadre.prototype//Asigna el prototipo del padre a la función
  prototipoHijo.prototype = new fn//Asigna una nueva instacia de prototipo a la clase Hija usando la misma de clase padre.
  prototipoHijo.prototype.constructor = prototipoHijo//Define que no compartan el mismo constructor el padre y el hijo.
}
heredaDe(Desarrollador, Persona)//Se debe invocar antes de declarar nuevos métodos de la clase.
Los EmaScript son las actualizaciones del lenguaje para trabajar de una manera mas fácil y efectiva con ciertas funcionalidades del lenguaje.
Una funcionalidad es la de tener clases que por debajo trabajan con herencia prototipal.
Para usar Herencia (basada en Herencia Prototipal) se usa la palabra reservada extends.
Para llamar al constructor de la clase padre se usa super(argumentos), y para llamar a un método dentro de la clase super.metodo() .

class Persona {
  constructor(nombre, apellido, altura) {
    this.nombre = nombre
    this.apellido = apellido
    this.altura = altura
  }

  saludar() {
    console.log(`Hola, me llamo ${this.nombre} ${this.apellido}`)
  }

  soyAlto() {
    return this.altura > 1.8
  }
}

class Desarrollador extends Persona{
  constructor(nombre, apellido, altura) {
    super(nombre,apellido,altura)//Llama al constructor del objeto padre.
  }

  saludar() {
    super.saludar();//Llama a la función del objeto Hijo.
    console.log(`Hola, me llamo ${this.nombre} ${this.apellido} y soy desarrollador/a`)
  }
}
En JavaScript es facilmente pasar una función como parámetro.
Al ingresar el nombre de una función la cual fue pasada como parámetro nos devuelve true si pasó y false si no.
JavaScript sólo puede hacer una cosa a la vez, sin embargo; es capaz de delegar la ejecución de ciertas funciones a otros procesos. Este modelo de concurrencia se llama EventLoop.
JavaScript delega en el navegador ciertas tareas y les asocia funciones que deberán ser ejecutadas al ser completadas. Estas funciones se llaman callbacks, y una vez que el navegador ha regresado con la respuesta, el callback asociado pasa a la cola de tareas para ser ejecutado una vez que JavaScript haya terminado todas las instrucciones que están en la pila de ejecución.
Si se acumulan funciones en la cola de tareas y JavaScript se encuentra ejecutando procesos muy pesados, el EventLoop quedará bloqueado y esas funciones pudieran tardar demasiado en ejecutarse.
Para comprobar el funcionamiento del event EventLoop se puede usar la función setTimeout( () => console.log("b"),ms), la cual realiza un llamado a la funcón despues de ocurrido el tiempo.
JQuery como una libreria para obtener datos de una API.
CDN Content Deliver Network (Servidor más cercano a nuestra ubicación).
Usar JQuery CDN minified (incluirla en el html).
Un callback es una función que se pasa a otra función como un argumento. Esta función se invoca, después, dentro de la función externa para completar alguna acción.
$.get(Url, options, function)// Obtener datos de una API.
Al ejecutar varios request podemos poner un orden pero cuando se ejecute dependerá de factores externos como el servidor, la red entre otros.
Una manera de asegurar que se respete la secuencia en que hemos realizado múltiples tareas es utilizando callbacks, con lo que se ejecutará luego, en cada llamada. Lo importante es que el llamado al callback se haga a través de una función anónima. Sin embargo, al hacerlo de esta manera generamos una situación poco deseada llamada CallbackHell.
Al ejecutar los callbacks encadenados se pierde el asincronismo de java y con ello una petición dependerá del tiempo que se ejecute la otra.
Con .fail(function) se ejecuta una función en caso de no lograr obtener el recurso.